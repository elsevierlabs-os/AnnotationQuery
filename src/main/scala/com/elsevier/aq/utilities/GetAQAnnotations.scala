package com.elsevier.aq.utilities

import java.net.URLDecoder
import scala.collection.mutable.ListBuffer
  
import org.apache.spark.sql.Dataset
import org.apache.spark.sql.SparkSession

import com.elsevier.aq.annotations.AQAnnotation
import com.elsevier.aq.annotations.CATAnnotation
  
/**
 * This function converts a Dataset[CATAnnotation] to a Dataset[AQAnnotation].  
 * A bare-bones AQAnnotation (with no properties) can be generated by only passing a Dataset[CATAnnotation]. 
 * If properties (name-value pairs from the CATAnnotation other column) are desired, you have the option of specifying an Array of names (from these name-value pairs).  
 * Additionally, you have the option of specifying if the values for these properties should be lower-cased and/or url decoded.
 */
class GetAQAnnotations(spark: SparkSession) { 
  
  import spark.implicits._
  
  /**
   * @param catAnnots Dataset[CATAnnotation].
   * @param props Array of property names  (from the name-value pairs in the other column in CATAnnotation) that you would like populated in the AQAnnotation Map of properties.
   * @param lcProps Array of property names where the value should be lower cased when populating the AQAnnotation Map of properties.
   * @param decodeProps Array of property names where the value should be url decoded when populating the AQAnnotation Map of properties.
   * @param numPartitions Number of partitions for the Dataset[AQAnnotation].
   * @return Dataset[AQAnnotation]
  */

  def apply(catAnnots:Dataset[CATAnnotation],  props:Array[String]=Array.empty[String], lcProps:Array[String]=Array.empty[String], decodeProps:Array[String]=Array.empty[String], numPartitions:Int=spark.conf.get("spark.sql.shuffle.partitions").toInt): Dataset[AQAnnotation] = {
    
    val ORIG = "orig"
    val ORIG_ANNOT_ID = "origAnnotID"
    val PARENT_ID = "parentId"
    val ATTR = "attr"
    val OM_NON_ATTRIBUTE_PROPERTIES = Array(ORIG, ORIG_ANNOT_ID, PARENT_ID)
    val OM_ANNOT_SET = "om"
    val WILDCARD = "*"
  
    catAnnots
         .map(annotation => {
         
            var propsMap = Map[String, String]()
            var attrBuf:ListBuffer[String] = new ListBuffer[String]()
         
            if (!props.isEmpty) {
              
              val otherToks = annotation.other.getOrElse("").split("&")
                   
              for(otherTok <- otherToks) {
                
                // Get the key-value pair
                val toks = otherTok.split("=")
                if (toks.size == 2) {
                  val key = toks(0)
                  var value = toks(1)

                  if (props.contains(key) || props.contains(WILDCARD)) {
                  
                    // Check if it should be url decoded
                    if (decodeProps.contains(key) || decodeProps.contains(WILDCARD)) {
                      value = URLDecoder.decode(value,"UTF-8")
                    }                  
                  
                    // Check if it should be lower cased
                    if (lcProps.contains(key) || lcProps.contains(WILDCARD)) {
                      value = value.toLowerCase
                    }
                  
                    if (props.contains(WILDCARD) && annotation.annotSet.toLowerCase == OM_ANNOT_SET && !(OM_NON_ATTRIBUTE_PROPERTIES.contains(key))) {
                      attrBuf += otherTok
                    } else {
                      // Add the entry to the map
                      propsMap += (key -> value)
                    }
               
                  } else if (props.contains(ATTR) && annotation.annotSet.toLowerCase == OM_ANNOT_SET) {   
                
                    if (!(OM_NON_ATTRIBUTE_PROPERTIES.contains(key))) {
                      attrBuf += otherTok
                    }
                  
                  }
                }
              }
            
              // Make sure there was not an attr property in the other column before overriding it
              if (attrBuf.size > 0 && !(propsMap.contains(ATTR))) {
                propsMap += (ATTR -> attrBuf.mkString("&"))
              }
              
            }
         
            AQAnnotation(annotation.docId,
                         annotation.annotSet,
                         annotation.annotType,
                         annotation.startOffset,
                         annotation.endOffset,
                         annotation.annotId,
                         if (propsMap.size > 0) Some(propsMap) else None)
         
         
     })
     .repartition(numPartitions, $"docId")                        
     .sortWithinPartitions($"docId",$"startOffset",$"endOffset") 
  }  
  
}