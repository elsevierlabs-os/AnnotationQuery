<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>annotation-query-spark3 1.0.7 API  - com.elsevier.aq.query</title>
          <meta name="description" content="annotation - query - spark3 1.0.7 API - com.elsevier.aq.query" />
          <meta name="keywords" content="annotation query spark3 1.0.7 API com.elsevier.aq.query" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../../index.js"></script>
      <script type="text/javascript" src="../../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">annotation-query-spark3 1.0.7 API<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.com" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="com"></a><a id="com:com"></a>
      <span class="permalink">
      <a href="../../../../com/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">com</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="com.elsevier" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elsevier"></a><a id="elsevier:elsevier"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">elsevier</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="com">com</a></dd></dl></div>
    </li><li name="com.elsevier.aq" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="aq"></a><a id="aq:aq"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">aq</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="com.elsevier">elsevier</a></dd></dl></div>
    </li><li name="com.elsevier.aq.annotations" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="annotations"></a><a id="annotations:annotations"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/annotations/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../annotations/index.html"><span class="name">annotations</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="com.elsevier.aq">aq</a></dd></dl></div>
    </li><li name="com.elsevier.aq.concordancers" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="concordancers"></a><a id="concordancers:concordancers"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/concordancers/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../concordancers/index.html"><span class="name">concordancers</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="com.elsevier.aq">aq</a></dd></dl></div>
    </li><li name="com.elsevier.aq.query" visbl="pub" class="indented4 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="query"></a><a id="query:query"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">query</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="com.elsevier.aq">aq</a></dd></dl></div>
    </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="After.html" title="Provide the ability to find annotations that are after another annotation."></a>
                        <a href="After.html" title="Provide the ability to find annotations that are after another annotation.">After</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="And.html" title="Provide the ability to find annotations that are in the same document."></a>
                        <a href="And.html" title="Provide the ability to find annotations that are in the same document.">And</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Before.html" title="Provide the ability to find annotations that are before another annotation."></a>
                        <a href="Before.html" title="Provide the ability to find annotations that are before another annotation.">Before</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Between.html" title="Provide the ability to find annotations that are before one annotation and after another."></a>
                        <a href="Between.html" title="Provide the ability to find annotations that are before one annotation and after another.">Between</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="ContainedIn.html" title="Provide the ability to find annotations that are contained by another annotation."></a>
                        <a href="ContainedIn.html" title="Provide the ability to find annotations that are contained by another annotation.">ContainedIn</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="ContainedInList.html" title="Provide the ability to find annotations that are contained by another annotation."></a>
                        <a href="ContainedInList.html" title="Provide the ability to find annotations that are contained by another annotation.">ContainedInList</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Contains.html" title="Provide the ability to find annotations that contain another annotation."></a>
                        <a href="Contains.html" title="Provide the ability to find annotations that contain another annotation.">Contains</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="FilterProperty.html" title="Provide the ability to filter a property field with  a specified value in a Dataset of AQAnnotations."></a>
                        <a href="FilterProperty.html" title="Provide the ability to filter a property field with  a specified value in a Dataset of AQAnnotations.">FilterProperty</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="FilterSet.html" title="Provide the ability to filter the annotation set field in a Dataset of AQAnnotations."></a>
                        <a href="FilterSet.html" title="Provide the ability to filter the annotation set field in a Dataset of AQAnnotations.">FilterSet</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="FilterType.html" title="Provide the ability to filter the annotation type field in a Dataset of AQAnnotations."></a>
                        <a href="FilterType.html" title="Provide the ability to filter the annotation type field in a Dataset of AQAnnotations.">FilterType</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Following.html" title="Return the followng sibling annotations for every annotation in the anchor Dataset[AQAnnotations]."></a>
                        <a href="Following.html" title="Return the followng sibling annotations for every annotation in the anchor Dataset[AQAnnotations].">Following</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="MatchProperty.html" title="Provide the ability to find annotations (looking at their property) that are in the same document."></a>
                        <a href="MatchProperty.html" title="Provide the ability to find annotations (looking at their property) that are in the same document.">MatchProperty</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Or.html" title="Provide the ability to combine (union) annotations."></a>
                        <a href="Or.html" title="Provide the ability to combine (union) annotations.">Or</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Preceding.html" title="Return the preceding sibling annotations for every annotation in the anchor Dataset[AQAnnotations]."></a>
                        <a href="Preceding.html" title="Return the preceding sibling annotations for every annotation in the anchor Dataset[AQAnnotations].">Preceding</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="RegexProperty.html" title="Provide the ability to filter a property field using a regex expression in a Dataset of AQAnnotations."></a>
                        <a href="RegexProperty.html" title="Provide the ability to filter a property field using a regex expression in a Dataset of AQAnnotations.">RegexProperty</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="RegexTokensSpan.html" title="Provides the ability to apply a regular expression to the concatenated string generated by TokensSpan."></a>
                        <a href="RegexTokensSpan.html" title="Provides the ability to apply a regular expression to the concatenated string generated by TokensSpan.">RegexTokensSpan</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="Sequence.html" title="Provide the ability to find annotations that are before another annotation."></a>
                        <a href="Sequence.html" title="Provide the ability to find annotations that are before another annotation.">Sequence</a>
                      </li><li class="current-entities indented4">
                        <span class="separator"></span>
                        <a class="class" href="TokensSpan.html" title="Provides the ability to create a string from a list of tokens that are contained in a span."></a>
                        <a href="TokensSpan.html" title="Provides the ability to create a string from a list of tokens that are contained in a span.">TokensSpan</a>
                      </li><li name="com.elsevier.aq.utilities" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="utilities"></a><a id="utilities:utilities"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/utilities/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../utilities/index.html"><span class="name">utilities</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="com.elsevier.aq">aq</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../../index.html" class="extype" name="com">com</a>.<a href="../../index.html" class="extype" name="com.elsevier">elsevier</a>.<a href="../index.html" class="extype" name="com.elsevier.aq">aq</a></p>
        <h1>query<span class="permalink">
      <a href="../../../../com/elsevier/aq/query/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">query</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"></div>
        

      

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="com.elsevier.aq.query.After" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AfterextendsAnyRef"></a><a id="After:After"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/After.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are after another annotation." href="After.html"><span class="name">After</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are after another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are after another annotation. The input is 2 Datasets of AQAnnotations. We will call them A and B.
The purpose is to find those annotations in A that are after B. What that means is the start offset for an annotation from A must be after the end offset from an annotation in B.
We of course have to also match on the document id. We ultimately return the A annotations that meet this criteria.
A distance operator can also be optionally specified.  This would require an A annotation (startOffset) to occur n characters (or less) after the B annotation (endOffset).
There is also the option of negating the query (think Not After) so that we return only A where it is not after B.
</p></div></div>
    </li><li name="com.elsevier.aq.query.And" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AndextendsAnyRef"></a><a id="And:And"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/And.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are in the same document." href="And.html"><span class="name">And</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are in the same document.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are in the same document. The input is 2 Datasets of AQAnnotations. We will call them A and B.
The purpose is to find those annotations in A and B that are in the same document.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Before" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BeforeextendsAnyRef"></a><a id="Before:Before"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Before.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are before another annotation." href="Before.html"><span class="name">Before</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are before another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are before another annotation. The input is 2 Datasets of AQAnnotations. We will call them A and B.
The purpose is to find those annotations in A that are before B. What that means is the end offset for an annotation from A must be before the start offset from an annotation in B.
We of course have to also match on the document id. We ultimately return the A annotations that meet this criteria.
A distance operator can also be optionally specified.  This would require an A annotation (endOffset) to occur n characters (or less) before the B annotation (startOffset).
There is also the option of negating the query (think Not Before) so that we return only A where it is not before B.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Between" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BetweenextendsAnyRef"></a><a id="Between:Between"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Between.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are before one annotation and after another." href="Between.html"><span class="name">Between</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are before one annotation and after another.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are before one annotation and after another. The input is 3 Datasets of AQAnnotations. We will call them A, B and C.
The purpose is to find those annotations in A that are before B and after C.
What that means is the end offset for an annotation from A must be before the start offset from an annotation in B and the start offset for A be after the end offset from C.
We of course have to also match on the document id. We ultimately return the A annotations that meet this criteria.
A distance operator can also be optionally specified. This would require an A annotation (endOffset) to occur n characters (or less) before the B annotation (startOffset) and would require the A annotation (startOffset) to occur n characters (or less) after the C annotation (endOffset) .
There is also the option of negating the query (think Not Between) so that we return only A where it is not before B nor after C.
</p></div></div>
    </li><li name="com.elsevier.aq.query.ContainedIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ContainedInextendsAnyRef"></a><a id="ContainedIn:ContainedIn"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/ContainedIn.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are contained by another annotation." href="ContainedIn.html"><span class="name">ContainedIn</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are contained by another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are contained by another annotation.  The input is 2 Datasets of AQAnnotations.  We will call them A and B.
The purpose is to find those annotations in A that are contained in B.  What that means is the start/end offset for an annotation from A  must be contained by the start/end offset from an annotation in  B.
We of course have to also match on the document id.  We ultimately return the contained annotations (A) that meet this criteria.
There is also the option of negating the query (think Not Contains) so that we return only A where it is not contained in B.
</p></div></div>
    </li><li name="com.elsevier.aq.query.ContainedInList" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ContainedInListextendsAnyRef"></a><a id="ContainedInList:ContainedInList"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/ContainedInList.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are contained by another annotation." href="ContainedInList.html"><span class="name">ContainedInList</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are contained by another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are contained by another annotation.  The input is 2 Datasets of AQAnnotations.  We will call them A and B.
The purpose is to find those annotations in A that are contained in B.  What that means is the start/end offset for an annotation from A  must be contained by the start/end offset from an annotation in  B.
We of course have to also match on the document id.
We ultimately return a Dataset with 2 fields where the first field is an annotation from B and the second field is an array of entries from A
that are contained in the first entry.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Contains" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ContainsextendsAnyRef"></a><a id="Contains:Contains"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Contains.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that contain another annotation." href="Contains.html"><span class="name">Contains</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that contain another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that contain another annotation.  The input is 2 Datasets of AQAnnotations.  We will call them A and B.
The purpose is to find those annotations in A that contain B.  What that means is the start/end offset for an annotation from A  must contain the start/end offset from an annotation in  B.
We of course have to also match on the document id.  We ultimately return the container annotations (A) that meet this criteria.
We also deduplicate the A annotations as there could be many annotations from B that could be contained by an annotation in A but it only makes sense to return the unique container annotations.
There is also the option of negating the query (think Not Contains) so that we return only A where it does not contain B.
</p></div></div>
    </li><li name="com.elsevier.aq.query.FilterProperty" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FilterPropertyextendsAnyRef"></a><a id="FilterProperty:FilterProperty"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/FilterProperty.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to filter a property field with  a specified value in a Dataset of AQAnnotations." href="FilterProperty.html"><span class="name">FilterProperty</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to filter a property field with  a specified value in a Dataset of AQAnnotations.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to filter a property field with  a specified value in a Dataset of AQAnnotations.
A single value or an array of values can be used for the filter comparison.
</p></div></div>
    </li><li name="com.elsevier.aq.query.FilterSet" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="FilterSetextendsAnyRef"></a><a id="FilterSet:FilterSet"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/FilterSet.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to filter the annotation set field in a Dataset of AQAnnotations." href="FilterSet.html"><span class="name">FilterSet</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to filter the annotation set field in a Dataset of AQAnnotations.</p>
    </li><li name="com.elsevier.aq.query.FilterType" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="FilterTypeextendsAnyRef"></a><a id="FilterType:FilterType"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/FilterType.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to filter the annotation type field in a Dataset of AQAnnotations." href="FilterType.html"><span class="name">FilterType</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to filter the annotation type field in a Dataset of AQAnnotations.</p>
    </li><li name="com.elsevier.aq.query.Following" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FollowingextendsAnyRef"></a><a id="Following:Following"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Following.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Return the followng sibling annotations for every annotation in the anchor Dataset[AQAnnotations]." href="Following.html"><span class="name">Following</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Return the followng sibling annotations for every annotation in the anchor Dataset[AQAnnotations].</p><div class="fullcomment"><div class="comment cmt"><p>Return the followng sibling annotations for every annotation in the anchor Dataset[AQAnnotations].
The following sibling annotations can optionally be required to be contained in a container Dataset[AQAnnotations].
The return type of this function is different from other functions.
Instead of returning a Dataset[AQAnnotation] this function returns a Dataset[(AQAnnotation,Array[AQAnnotation])].
</p></div></div>
    </li><li name="com.elsevier.aq.query.MatchProperty" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MatchPropertyextendsAnyRef"></a><a id="MatchProperty:MatchProperty"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/MatchProperty.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations (looking at their property) that are in the same document." href="MatchProperty.html"><span class="name">MatchProperty</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations (looking at their property) that are in the same document.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations (looking at their property) that are in the same document. The input is 2 Datasets of AQAnnotations. We will call them A and B.
The purpose is to find those annotations in A that are in the same document as B and also match values on the specified property.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Or" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OrextendsAnyRef"></a><a id="Or:Or"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Or.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to combine (union) annotations." href="Or.html"><span class="name">Or</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to combine (union) annotations.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to combine (union) annotations. The input is 2 Datasets of AQAnnotations. The output is the union of these annotations.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Preceding" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PrecedingextendsAnyRef"></a><a id="Preceding:Preceding"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Preceding.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Return the preceding sibling annotations for every annotation in the anchor Dataset[AQAnnotations]." href="Preceding.html"><span class="name">Preceding</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Return the preceding sibling annotations for every annotation in the anchor Dataset[AQAnnotations].</p><div class="fullcomment"><div class="comment cmt"><p>Return the preceding sibling annotations for every annotation in the anchor Dataset[AQAnnotations].
The preceding sibling annotations can optionally be required to be contained in a container Dataset[AQAnnotations].
The return type of this function is different from other functions.
Instead of returning a Dataset[AQAnnotation] this function returns a Dataset[(AQAnnotation,Array[AQAnnotation])].
</p></div></div>
    </li><li name="com.elsevier.aq.query.RegexProperty" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RegexPropertyextendsAnyRef"></a><a id="RegexProperty:RegexProperty"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/RegexProperty.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to filter a property field using a regex expression in a Dataset of AQAnnotations." href="RegexProperty.html"><span class="name">RegexProperty</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to filter a property field using a regex expression in a Dataset of AQAnnotations.</p>
    </li><li name="com.elsevier.aq.query.RegexTokensSpan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RegexTokensSpanextendsAnyRef"></a><a id="RegexTokensSpan:RegexTokensSpan"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/RegexTokensSpan.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides the ability to apply a regular expression to the concatenated string generated by TokensSpan." href="RegexTokensSpan.html"><span class="name">RegexTokensSpan</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides the ability to apply a regular expression to the concatenated string generated by TokensSpan.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the ability to apply a regular expression to the concatenated string generated by TokensSpan. For the strings matching the regex,
a Dataset[AQAnnotations] will be returned.  The AQAnnotation will correspond to the offsets within the concatenated string containing the match.
</p></div></div>
    </li><li name="com.elsevier.aq.query.Sequence" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SequenceextendsAnyRef"></a><a id="Sequence:Sequence"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/Sequence.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provide the ability to find annotations that are before another annotation." href="Sequence.html"><span class="name">Sequence</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provide the ability to find annotations that are before another annotation.</p><div class="fullcomment"><div class="comment cmt"><p>Provide the ability to find annotations that are before another annotation. The input is 2 Datasets of AQAnnotations. We will call them A and B.
The purpose is to find those annotations in A that are before B. What that means is the end offset for an annotation from A must be before the start offset from an annotation in B.
We of course have to also match on the document id. We ultimately return the annotations that meet this criteria. Unlike the Before function, we adjust the returned annotation a bit.
For example, we set the annotType to &quot;seq&quot; and we use the A startOffset and the B endOffset.
A distance operator can also be optionally specified.  This would require an A annotation (endOffset) to occur n characters (or less) before the B annotation (startOffset).
</p></div></div>
    </li><li name="com.elsevier.aq.query.TokensSpan" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TokensSpanextendsAnyRef"></a><a id="TokensSpan:TokensSpan"></a>
      <span class="permalink">
      <a href="../../../../com/elsevier/aq/query/TokensSpan.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides the ability to create a string from a list of tokens that are contained in a span." href="TokensSpan.html"><span class="name">TokensSpan</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides the ability to create a string from a list of tokens that are contained in a span.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the ability to create a string from a list of tokens that are contained in a span. The specified tokenProperty is used to extract the values from the tokens when creating the string.
For SCNLP, this tokenProperty could be values like 'orig', 'lemma', or 'pos'. The spans would typically be a SCNLP 'sentence' or could even be things like an OM 'ce:para'.
Returns a Dataset[AQAnnotation] spans with 3 new properties all prefixed with the specified tokenProperty value followed by (ToksStr, ToksSpos, ToksEpos) The ToksStr property will be the
concatenated string of token property values contained in the span. The ToksSPos and ToksEpos are properties that will help us determine the start/end offset for each of the individual tokens in the ToksStr.
These helper properties are needed for the function RegexTokensSpan so we can generate accurate accurate start/end offsets based on the str file.
</p></div></div>
    </li></ol>
            </div>

        

        

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
